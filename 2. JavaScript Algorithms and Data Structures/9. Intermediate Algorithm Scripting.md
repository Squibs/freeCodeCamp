# Intermediate Algorithm Scripting

Definitely compare my old answer to these new ones. Some are just copy pastes, but many I did change to be more optimal.

List of Sections:

<!-- TOC -->

- [Introduction to Intermediate Algorithm Scripting](#introduction-to-intermediate-algorithm-scripting)
- [Sum All Numbers in a Range](#sum-all-numbers-in-a-range)
- [Diff Two Arrays](#diff-two-arrays)
- [Seek and Destroy](#seek-and-destroy)
- [Wherefore art thou](#wherefore-art-thou)
- [Spinal Tap Case](#spinal-tap-case)
- [Pig Latin](#pig-latin)
- [Search and Replace](#search-and-replace)
- [DNA Pairing](#dna-pairing)
- [Missing letters](#missing-letters)
- [Sorted Union](#sorted-union)
- [Convert HTML Entities](#convert-html-entities)
- [Sum All Odd Fibonacci Numbers](#sum-all-odd-fibonacci-numbers)
- [Sum All Primes](#sum-all-primes)
- [Smallest Common Multiple](#smallest-common-multiple)
- [Drop it](#drop-it)
- [Steamroller](#steamroller)
- [Binary Agents](#binary-agents)
- [Everything Be True](#everything-be-true)
- [Arguments Optional](#arguments-optional)
- [Make a Person](#make-a-person)
- [Map the Debris](#map-the-debris)

<!-- /TOC -->

---

## Introduction to Intermediate Algorithm Scripting

I have some older notes for this *Intermediate Algorithm Scripting* section that can be viewed:

- [Old Intermediate Algorithm Scripting Notes](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Notes/Intermediate%20Algorithm%20Scripting%20Notes%20-%20OLD.md#intermediate-algorithm-scripting)

---

## Sum All Numbers in a Range

```JavaScript
function sumAll(arr) {
  let sum = 0;
  for (let i = Math.min(arr[0], arr[1]); i <= Math.max(arr[0], arr[1]); i += 1) {
    sum += i;
  }
  return sum;
}

console.log(sumAll([1, 4])); // should return a number.
console.log(sumAll([1, 4])); // should return 10.
console.log(sumAll([4, 1])); // should return 10.
console.log(sumAll([5, 10])); // should return 45.
console.log(sumAll([10, 5])); // should return 45.
```

*This is my revised solution to the last time I attempted this challenge. It's practically the same solution I came up with before, just a few lines are merged on this solution.*

Looking at the provided solutions, it is similar to the advanced solution, however the advanced solution uses the spread (`...`) operator instead of listing arr[0], arr[1] in the `Math.min()` method. Which would help clean up what I came up with.

```JavaScript
for (let i = Math.min(...arr); i <= Math.max(...arr); i += 1) { }
```

Another solution for this problem would be to just use a math based solution:

`((max + min) * (max - min + 1)) / 2` - to find the sum of a range of numbers

```JavaScript
function sumAll(arr) {
  const min = Math.min(...arr);
  const max = Math.max(...arr);
  return (((max + min) * (max - min + 1)) / 2);
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/sum-numbers-range-old.js#L1)***

---

## Diff Two Arrays

```JavaScript
function diffArray(arr1, arr2) {
  return arr1.concat(arr2).sort().filter((value, index, array) => (value !== array[index - 1] && value !== array[index + 1]));
}

console.log(diffArray(['diorite', 'andesite', 'grass', 'dirt', 'pink wool', 'dead shrub'], ['diorite', 'andesite', 'grass', 'dirt', 'dead shrub'])); // should return ['pink wool'].
console.log(diffArray(['andesite', 'grass', 'dirt', 'pink wool', 'dead shrub'], ['diorite', 'andesite', 'grass', 'dirt', 'dead shrub'])); // should return ['diorite', 'pink wool'].
console.log(diffArray(['andesite', 'grass', 'dirt', 'dead shrub'], ['andesite', 'grass', 'dirt', 'dead shrub'])); // should return [].
console.log(diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5])); // should return [4].
console.log(diffArray([1, 'calf', 3, 'piglet'], [1, 'calf', 3, 4])); // should return ['piglet', 4].
console.log(diffArray([], ['snuffleupagus', 'cookie monster', 'elmo'])); // should return ['snuffleupagus', 'cookie monster', 'elmo'].
console.log(diffArray([1, 'calf', 3, 'piglet'], [7, 'filly'])); // should return [1, 'calf', 3, 'piglet', 7, 'filly'].
```

This is the solution I ended up with this time around. I combine the two arrays with `concat` then I `sort` the now combined array so that the duplicate values will be next two each other. I then use `filter` the array and return values that are not equal to those that are in front of or behind of the current value, which leaves only the values that appeared once in the sorted, combined array.

Looking at the solutions, I could definitely shorten my solution. I could also simply check if the current value (in the `filter()` method) is in either array and if it is return false; rather than checking ahead and behind when using the `filter()` method.

Provided solution:

```JavaScript
function diffArray(arr1, arr2) {
  return arr1.concat(arr2).filter(item => !arr1.includes(item) || !arr2.includes(item));
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/diff-two-arrays-old.js#L1)***

---

## Seek and Destroy

```JavaScript
function destroyer(arr) {
  const args = [...arguments].slice(1);
  return arr.filter(value => !args.includes(value));
}

console.log(destroyer([1, 2, 3, 1, 2, 3], 2, 3)); // should return [1, 1].
console.log(destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3)); // should return [1, 5, 1].
console.log(destroyer([3, 5, 1, 2, 2], 2, 3, 5)); // should return [1].
console.log(destroyer([2, 3, 2, 3], 2, 3)); // should return [].
console.log(destroyer(['tree', 'hamburger', 53], 'tree', 53)); // should return ['hamburger'].
console.log(destroyer(['possum', 'trollo', 12, 'safari', 'hotdog', 92, 65, 'grandma', 'bugati', 'trojan', 'yacht'], 'yacht', 'possum', 'trollo', 'safari', 'hotdog', 'grandma', 'bugati', 'trojan')); // should return [12,92,65].
```

The `includes()` method was considered an experimental feature the first time I went through this challenge. However, now it seems to be supported across all browsers except for internet explorer.

A solution I came up with later uses the `includes()` method as well; however this time it uses `destructuring` along with the `arguments` object (this removes the use of the `slice()` method).

```JavaScript
function destroyer(arr) {
  const [, ...remove] = arguments;
  return arr.filter(value => !remove.includes(value));
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/seek-and-destroy-old.js#L1)***

---

## Wherefore art thou

```JavaScript
function whatIsInAName(collection, source) {
  const keys = Object.keys(source);
  return collection.filter(value => keys.every(key => source[key] === value[key]));
}

/* eslint-disable */
console.log(whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" })); // should return [{ first: "Tybalt", last: "Capulet" }].
console.log(whatIsInAName([{ "apple": 1 }, { "apple": 1 }, { "apple": 1, "bat": 2 }], { "apple": 1 })); // should return [{ "apple": 1 }, { "apple": 1 }, { "apple": 1, "bat": 2 }].
console.log(whatIsInAName([{ "apple": 1, "bat": 2 }, { "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "bat": 2 })); // should return [{ "apple": 1, "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }].
console.log(whatIsInAName([{ "apple": 1, "bat": 2 }, { "apple": 1 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "cookie": 2 })); // should return [{ "apple": 1, "bat": 2, "cookie": 2 }].
console.log(whatIsInAName([{ "apple": 1, "bat": 2 }, { "apple": 1 }, { "apple": 1, "bat": 2, "cookie": 2 }, { "bat":2 }], { "apple": 1, "bat": 2 })); // should return [{ "apple": 1, "bat": 2 }, { "apple": 1, "bat": 2, "cookie":2 }].
console.log(whatIsInAName([{"a": 1, "b": 2, "c": 3}], {"a": 1, "b": 9999, "c": 3})); // should return []
```

To solve this problem, I first create a collection of keys from the passed `source` using the `Object` object; along with its `keys()` function. Using this array of `keys` I use the `filter()` method on the passed `collection` array of objects, and compare every value to every key in the `keys` array. If the value of the key in the current `collection` object is not equal to the value of the key in the current `source` object, then it returns false and removes it from the array.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/wherefore-art-thou-old.js#L1)***

---

## Spinal Tap Case

```JavaScript
function spinalCase(str) {
  return str.split(/(?=[A-Z])|[_\s-]/).join('-').toLowerCase();
}

console.log(spinalCase('This Is Spinal Tap')); // should return 'this-is-spinal-tap'.
console.log(spinalCase('thisIsSpinalTap')); // should return 'this-is-spinal-tap'.
console.log(spinalCase('The_Andy_Griffith_Show')); // should return 'the-andy-griffith-show'.
console.log(spinalCase('Teletubbies say Eh-oh')); // should return 'teletubbies-say-eh-oh'.
console.log(spinalCase('AllThe-small Things')); // should return 'all-the-small-things'.
```

I use the `split()` method to split the original string before any capital letter ( `(?=[A-Z])` ) or (`|`) on underscores, any whitespace character, or on hyphens (`[_\s-]`). I then join the now split up words in the newly created array with hyphens in-between with `join()` method. I then set the entire string to lowercase using the `toLowerCase()` method.

OLD SOLUTION:

```JavaScript
function spinalCase(str) {
  return str.replace(/[A-Z]/g, ' $&').split(/[\W_]/g).filter(value => value.trim()).join('-').toLowerCase();
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/spinal-tap-case-old.js#L1)***

---

## Pig Latin

```JavaScript
function translatePigLatin(str) {
  const search = str.search(/[aeiou]/);
  return search === -1 ? `${str}ay` : `${str.slice(search)}${str.slice(0, search)}${str.match(/^[aeiou]/) ? 'way' : 'ay'}`;
}

console.log(translatePigLatin('california')); // should return 'aliforniacay'.
console.log(translatePigLatin('paragraphs')); // should return 'aragraphspay'.
console.log(translatePigLatin('glove')); // should return 'oveglay'.
console.log(translatePigLatin('algorithm')); // should return 'algorithmway'.
console.log(translatePigLatin('eight')); // should return 'eightway'.
console.log(translatePigLatin('tsktsks')); // should return 'tsktsksay'.
// Should handle words where the first vowel comes in the end of the word.
// Should handle words without vowels.
```

This answer is pretty much the same as my old answer, only I don't split the string into an array in this answer. I have a variable (`search`) which uses the `search()` method on the passed string to look for the first instance (stores the index) of any character of `aeiou`. I then start my return statement. I check if the `search` variable is holding an index of `-1` which basically means the word does not have any vowels in it. If the word has no vowels, then just return the word exactly as is with `ay` tacked onto the end of it. Otherwise, I use the `slice()` method to get the end of the word, every letter after that index, then add the first part of the word using `slice()` again; this time from the start of the string through the index. Then I add `way` or `ay` to the end of the word depending on if the word has a vowel at the very start of it or not using the `match()` function.

OLD SOLUTION:

```JavaScript
function translatePigLatin(str) {
  const regex = /[aeiou]/;
  const search = str.search(regex);
  const length = str.split('').splice(0, search).length;
  return search === -1 ? `${str}ay` : `${str.slice(search)}${length > 0 ? str.split('').splice(0, search).join('') : 'w'}ay`;
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/pig-latin-old.js#L1)***

---

## Search and Replace

```JavaScript
function myReplace(str, before, after) {
  // return /^[A-Z]/.test(before) ? str.replace(before, `${after[0].toUpperCase()}${after.slice(1)}`) : str.replace(before, after);
  return str.replace(before, value => (/^[A-Z]/.test(value) ? `${after[0].toUpperCase()}${after.slice(1)}` : after));
}

console.log(myReplace('Let us go to the store', 'store', 'mall')); // should return 'Let us go to the mall'.
console.log(myReplace('He is Sleeping on the couch', 'Sleeping', 'sitting')); // should return 'He is Sitting on the couch'.
console.log(myReplace('This has a spellngi error', 'spellngi', 'spelling')); // should return 'This has a spelling error'.
console.log(myReplace('His name is Tom', 'Tom', 'john')); // should return 'His name is John'.
console.log(myReplace('Let us get back to more Coding', 'Coding', 'algorithms')); // should return 'Let us get back to more Algorithms'.
```

When coming up with this solution, I originally came up with the commented out return statement above, but after comparing to my old solution, I realized I could combine my two answers.

I start by using the `replace()` method on the passed string, I want to replace the passed `before` string with the `after` string, but I need to adhere to the capitalization of the `before` string. So I iterate through each `value` (which there is only one) and test if the `value` is capitalized or not with the `test()` method on a regex pattern. If the `before` is capitalized I then return the first character of the `after` string uppercase with the `toUpperCase()` method concatenated with the rest of the `after` string with the `slice()` method leaving off the first character. If the `before` is not capitalized I simply return the `after` string as is.

OLD SOLUTION:

```JavaScript
function myReplace(str, before, after) {
  return str.replace(before, value => (value[0] === value[0].toUpperCase() ? `${after.charAt(0).toUpperCase()}${after.slice(1)}` : after.toLowerCase()));
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/search-and-replace-old.js#L1)***

---

## DNA Pairing

```JavaScript
function pairElement(str) {
  const pairs = { T: 'A', A: 'T', C: 'G', G: 'C' };
  return str.split('').map(value => [value, pairs[value]]);
}

console.log(pairElement('ATCGA')); // should return [['A','T'],['T','A'],['C','G'],['G','C'],['A','T']].
console.log(pairElement('TTGAG')); // should return [['T','A'],['T','A'],['G','C'],['A','T'],['G','C']].
console.log(pairElement('CTCTA')); // should return [['C','G'],['T','A'],['C','G'],['T','A'],['A','T']].
```

I use a object literal to store the four possible DNA pairs in a variable named `pairs`, which will serve as a lookup for my solution. I first split the passed string with the `split()` method into an array of each character. I then map through this created array and return a multi-dimensional array which contains arrays of each value in an array with its pair by simply using the lookup `pairs` variable and passing each `value` in bracket notation as an accessor.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/dna-pairing-old.js#L1)***

---

## Missing letters

```JavaScript
function fearNotLetter(str) {
  const missing = str.split('').find((element, index) => element.charCodeAt(0) !== str.charCodeAt(0) + index);
  return missing === undefined ? undefined : String.fromCharCode(missing.charCodeAt(0) - 1);
}

console.log(fearNotLetter('abce')); // should return 'd'.
console.log(fearNotLetter('abcdefghjklmno')); // should return 'i'.
console.log(fearNotLetter('stvwx')); // should return 'u'.
console.log(fearNotLetter('bcdf')); // should return 'e'.
console.log(fearNotLetter('abcdefghijklmnopqrstuvwxyz')); // should return undefined.
```

I still feel like this could be improved, so that the `missing` variable does not have to be called upon, but I am unsure at this current time how I could improve my solution at this time.

I store the letter that comes after the missing letter, or `undefined` if no letter is missing. I do this by using the `split()` method to split the string into an array and then using the `find()` method to iterate through the array. I compare each value's UTF-16 code to that of the first UTF-16 code of the passed string plus the index of the current value. If the values match then it compares the next array element until they all match or the missing letter is found. I then check if the `missing` variable is `undefined` and return `undefined` if it is so, otherwise I return the correct letter by subtracting one from the previously found UTF-16 code.

OLD SOLUTION:

```JavaScript
function fearNotLetter(str) {
  let number = str.charCodeAt(0) - 1;
  const missing = str.split('').find((value) => {
    number += 1;
    return value !== String.fromCharCode(number);
  });
  return missing === undefined ? undefined : String.fromCharCode(missing.charCodeAt(0) - 1);
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/missing-letters-old.js#L1)***

---

## Sorted Union

```JavaScript
function uniteUnique(...arr) {
  return [...new Set(arr.reduce((prev, cur) => prev.concat(cur)))];
}

console.log(uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1])); // should return [1, 3, 2, 5, 4].
console.log(uniteUnique([1, 3, 2], [1, [5]], [2, [4]])); // should return [1, 3, 2, [5], [4]].
console.log(uniteUnique([1, 2, 3], [5, 2, 1])); // should return [1, 2, 3, 5].
console.log(uniteUnique([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8])); // should return [1, 2, 3, 5, 4, 6, 7, 8].
```

Learned about the `Set` object. It's like an object but without keys; just a ~~list~~ set of values.

The `Set` object lets you store unique values of any type, whether primitive values or object references. The keyword here being *unique*. This means if you pass in multiple of the same value, then only one will be part of the `Set`.

Example usage of the `Set` object here:

```JavaScript
new Set([1, 1, 1, 2, 2, 3]); // creates: Set { 1, 2, 3 }
...new Set([1, 1, 1, 2, 2, 3]); // creates: 1 2 3
[...new Set([1, 1, 1, 2, 2, 3])]; // creates: [1, 2, 3]

new Set([1, [2], 2, 3, 4, 5, [5], 1, 2, 3, 6]); // creates: Set { 1, [2], 2, 3, 4, 5, [5], 6 }
```

A listed solution for this challenge is:

```JavaScript
function uniteUnique(arr) {
  return [...new Set([].concat(...arguments))];
}
```

This makes an array out of the arguments and flattens it, using the spread operator. This flattened array is then turned into a new `Set` using the `Set` object. Which in turn is turned into an array via the surrounding brackets ( `[` `]` ).

Abiding by eslint rules (this should be the answer I submitted instead of using the `reduce()` method):

```JavaScript
function uniteUnique(...arr) {
  return [...new Set([].concat(...arr))];
}
```

This uses the `spread` operator in the accepted arguments of the function to create a new variable `arr`, which can then be used in place of the `arguments` keyword.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/sorted-union-old.js#L1)***

---

## Convert HTML Entities

```JavaScript
function convertHTML(str) {
  const lookup = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&apos;' };
  return str.split('').map(value => lookup[value] || value).join('');
}

/* eslint-disable */
console.log(convertHTML("Dolce & Gabbana")); // should return Dolce &​amp; Gabbana.
console.log(convertHTML("Hamburgers < Pizza < Tacos")); // should return Hamburgers &​lt; Pizza &​lt; Tacos.
console.log(convertHTML("Sixty > twelve")); // should return Sixty &​gt; twelve.
console.log(convertHTML('Stuff in "quotation marks"')); // should return Stuff in &​quot;quotation marks&​quot;.
console.log(convertHTML("Schindler's List")); // should return Schindler&​apos;s List.
console.log(convertHTML("<>")); // should return &​lt;&​gt;.
console.log(convertHTML("abc")); // should return abc.
```

I simply create an object to use as a lookup as to what should be replaced in each string. To use this `lookup` object variable, I first split the string up into an array of single characters using the `split()` method. I then use the `map()` method to iterate through the new array of single characters. I compare each value in this array with the `lookup` object variable and if the key is in there it will return the correct HTML entity. If not it just returns the same value back

Once again I feel like the most important thing I have learned from this challenge is when to be use the logical-OR operator (`||`) versus using the conditional operator (`?`). If I am repeating some kind of check for example: 

`lookup[value] === undefined ? value : lookup[value]`

I could instead just use the logical-OR operator (`||`):

`lookup[value] || value`

OLD SOLUTION:

```JavaScript
function convertHTML(str) {
  const lookup = { 34: '&quot;', 38: '&amp;', 39: '&apos;', 60: '&lt;', 62: '&gt;' };
  return str.split('').map(value => (lookup[value.charCodeAt(0)] !== undefined ? lookup[value.charCodeAt(0)] : value)).join('');
}
```

Looking at the answer I should be using `||` or operands instead of conditionals more often or at least be more aware of when I can use them. Should have written it like this:

```JavaScript
function convertHTML(str) {
  const lookup = { 34: '&quot;', 38: '&amp;', 39: '&apos;', 60: '&lt;', 62: '&gt;' };
  return str.split('').map(value => lookup[value.charCodeAt(0)] || value).join('');
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/convert-html-entities-old.js#L1)***

---

## Sum All Odd Fibonacci Numbers

```JavaScript
function sumFibs(num) {
  const fib = [0, 1];

  for (let i = 1; i <= num;) {
    fib.push(i);
    i = fib[fib.length - 1] + fib[fib.length - 2];
  }

  return fib.reduce((prev, cur) => (cur % 2 === 0 ? prev : prev + cur));
}

console.log(sumFibs(1)); // should return a number.
console.log(sumFibs(1000)); // should return 1785.
console.log(sumFibs(4000000)); // should return 4613732.
console.log(sumFibs(4)); // should return 5.
console.log(sumFibs(75024)); // should return 60696.
console.log(sumFibs(75025)); // should return 135721.
```

To solve this challenge, I created a variable, `fib`, which will hold the entire fibonacci sequence up to a specific point (in an array), based on the passed number. Using a `for` loop, I simply push the value of another variable, `i`, to the `fib` variable. Each loop `i` is then set to the sum of the value of the last index of the the `fib` array and the value of the second to last index of the `fib` array. This continues until `i` is greater than or equal to the passed `num`.

I then use the `reduce()` method on the `fib` array to add all the odd fibonacci numbers together. To check for odd numbers I simply divide each number by 2 and check if the remainder is 0 or not (using the remainder/modulo operator `%`). If the number is even (0), then I return the previous value, otherwise I return the sum of the previous value and the current value. This will find the sum of all the odd numbers in the `fib` array.

An important lesson learned from this challenge, is that a `for` loop can be used in a way similar to a `while` loop; where the control variable is incremented inside the loop rather than at the start of each loop. This makes both the first statement and third statement in a `for` loop optional.

*A `while` loop definitely could have been used to solve this challenge as well.*

A `recursive` solution to this challenge could be:

```JavaScript
function sumFibs(num, fib = [0, 1], i = 1) {
  fib.push(i);
  const j = fib[fib.length - 1] + fib[fib.length - 2];
  return j <= num ? sumFibs(num, fib, j) : fib.reduce((prev, cur) => (cur % 2 === 0 ? prev : prev + cur));
}
```

I created this while seeing if it was possible to create a `recursive` solution to this challenge. This simply removes the need for the `for` loop, while keeping everything else pretty much the same.

I start using the variable `j` to avoid reassigning the `i` variable. It is entirely possible to keep using the `i` variable and simply reassign it; I was trying to adhere to AirBnB/ESLint rules.

Looking through the comments for the provided solutions to this challenge I came across this `recursive` solution:

```JavaScript
const sumFibs = (num, prev = 0, cur = 1, sum = 0) => (
  cur > num ? sum : sumFibs(num, cur, prev + cur, sum + (cur % 2 && cur))
);
```

This solution makes the `recursive` solution even simpler. If the current value is greater than the passed number return the sum otherwise pass the number, the current value as the previous value, the sum of the previous value and the current value as the current value, and the sum plus the current value as the sum (unless the current value is even).

There is a few things I learned from this solution:

The use of the logical-AND (`&&`) in a non-conditional statement; if that makes any sense at all.

I'm used to using the `&&` operator in a way where both expressions on either side of the `&&` operator must be true in order for something to occur. For example: `if the length is equal to or greater than 12 AND (&&) is less than 100 THEN do something`. This is a great example of using `&&` in another way.

`expr1 && expr2` - Returns `expr1` if it can be converted to `false`; otherwise, returns `expr2`. Thus, when used with Boolean values (like my above pseudocode example), `&&` returns `true` if both operands are true; otherwise returns `false`.

To summarize, `&&` can be used to return something other than `true` or `false`.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/fibonacci-numbers-old.js#L1)***

---

## Sum All Primes

```JavaScript
const sumPrimes = function (num) {
  if (num === 1) {
    console.log('Passed number is 1, which is not prime; return 0\n');
    return 0;
  }

  let sieve = [];
  const primes = [];

  for (let i = 2; i <= num; i += 1) {
    sieve.push(i);
  }

  while (sieve.length) {
    primes.push(sieve.shift());
    sieve = sieve.filter(value => value % primes[primes.length - 1] !== 0);
  }

  return primes.reduce((acc, cur) => acc + cur, 0);
};

console.log(sumPrimes(10)); // should return 17.
console.log(sumPrimes(977)); // should return 73156.
```

The *`Sieve of Eratosthenes`* is a great way to solve this challenge. You generate all numbers from 2 through the passed number and store that in the `sieve` variable; with a `for` loop. Once this array of numbers is created it is then sent through a `while` loop, that will repeat until the `sieve` array is empty. On each loop, the first number is removed from the `sieve` and pushed into another array `primes` (using the `push()` and `shift()` methods). Then the through the use of the `filter()` method, non-primes are removed from the remaining numbers in the `sieve` array. Each value left in the `sieve` is checked for a remainder against the last number added to the `primes` array. If the current value has a remainder other than 0, then it is removed from the sieve. Once this loop has completed then the `primes` array is reduced to a sum using the `reduce()` method and returned.

[Wikipedia Article on the Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) - Contains a great visualization on how this sieving method works.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/sum-all-primes-old.js#L1)***

---

## Smallest Common Multiple

```JavaScript
function smallestCommons(arr) {
  const minimum = Math.min(arr[0], arr[1]);
  const maximum = Math.max(arr[0], arr[1]);
  let SCM = maximum;

  function multiples(min, max, total) {
    for (let i = min; i <= max; i += 1) {
      if (total % i !== 0) { return true; }
    }
    return false;
  }

  while (multiples(minimum, maximum, SCM)) {
    SCM += maximum;
  }

  return SCM;
}

console.log(smallestCommons([1, 5])); // should return 60.
console.log(smallestCommons([5, 1])); // should return 60.
console.log(smallestCommons([2, 10])); // should return 2520.
console.log(smallestCommons([1, 13])); // should return 360360.
console.log(smallestCommons([23, 18])); // should return 6056820.
```

In order to solve this challenge, I created another function within this function called `multiples`. This function takes a `min`, `max`, and a `total`. `multiples` has a for loop that will repeat the difference between the `min` and `max` number of times. Each time it will check if the remainder between the `total` and the current `i` value in the loop is equal to `0` or not.

The `minimum` and `maximum` which are passed into the `smallestCommons` function are passed into the nested function `multiples` along with the variable `SCM` which is tracking the current `total` (which will be the lowest common multiple in the end) controlled by a `while` loop. This `while` loop will continuously call the `multiples` function until that function returns false; it will only return false when the the smallest/least common multiple has been found. The `maximum` is added to the `SCM` variable on each loop of the `while` loop.

I believe a real additional challenge, for this challenge, would be to find a solution that is performance optimized. Sure my solution can find the solution, but I am fairly certain there could be a better way to solve this challenge than running loops several thousands/millions of times over until a solution is found.

The provided solutions mentions the implementation of the `Euclidean Algorithm` in this way:

```JavaScript
function gcd(x, y) {
  if (y === 0) return x;
  return gcd(y, x % y);
}
```

This finds the *greatest common divisor* between two positive integers. They mention the intermediate solution they give solves the test cases in a much smaller amount of loop counts; for example solving `smallestCommons(1,25)` in around 40 loops.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/smallest-multiple-old.js#L1)***

---

## Drop it

```JavaScript
function dropElements(arr, func) {
  const foundIndex = arr.findIndex(func);
  return foundIndex === -1 ? [] : arr.slice(foundIndex);
}

/* eslint-disable */
console.log(dropElements([1, 2, 3, 4], function(n) {return n >= 3;})); // should return [3, 4].
console.log(dropElements([0, 1, 0, 1], function(n) {return n === 1;})); // should return [1, 0, 1].
console.log(dropElements([1, 2, 3], function(n) {return n > 0;})); // should return [1, 2, 3].
console.log(dropElements([1, 2, 3, 4], function(n) {return n > 5;})); // should return [].
console.log(dropElements([1, 2, 3, 7, 4], function(n) {return n > 3;})); // should return [7, 4].
console.log(dropElements([1, 2, 3, 9, 2], function(n) {return n > 2;})); // should return [3, 9, 2].
```

I believe the purpose of this challenge is to show that a function can be passed as an argument to another function.

One thing I learned while doing this challenge is that when you want to iterate through the array and pass each array element through this passed function; you can simply shorthand `arr.findIndex(element => func(element));` to `arr.findIndex(func);`. This will automatically push every array element through this passed function and return the same result.

I first create a variable `foundIndex` which stores the result, an index, of the first array element that passes the test of the passed function. I then check if this stored index is equal to `-1` or not (`-1` means that no array element passed the test). If no array element passed the test, I return an empty array. Otherwise I return a slice of the array using the `slice()` method.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/drop-it-old.js#L1)***

---

## Steamroller

```JavaScript
function steamrollArray(arr) {
  return arr.reduce((prev, cur) => prev.concat(Array.isArray(cur) ? steamrollArray(cur) : cur), []);
}

/* eslint-disable */
console.log(steamrollArray([[["a"]], [["b"]]])); // should return ["a", "b"].
console.log(steamrollArray([1, [2], [3, [[4]]]])); // should return [1, 2, 3, 4].
console.log(steamrollArray([1, [], [3, [[4]]]])); // should return [1, 3, 4].
console.log(steamrollArray([1, {}, [3, [[4]]]])); // should return [1, {}, 3, 4].
```

The solution to this challenge can be found using a solution from the *Sorted Union* challenge. The *Sorted Union* challenge used the `reduce()` method in order to concatenate several arrays, and flatten them to a degree. The same can be done here.

Using the `reduce()` method on the passed array `arr`, I can iterate through each of the values in the array. I use the `concat()` method on the previous value `prev`and check if the current value `cur` is in-fact an array or not. If the current value, `cur`, is an array flatten the array with the same function that is already flattening the array (using `recursion`); otherwise concat the current value to the previous value. I then also have the `concat()` method set to an initial value of an empty array `[]`.

OLD SOLUTION:

```JavaScript
function steamrollArray(arr) {
  function flattenArray(array) {
    return array.reduce((prev, cur) => prev.concat(Array.isArray(cur) ? flattenArray(cur) : cur), []);
  }
  return flattenArray(arr);
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/steamroller-old.js#L1)***

---

## Binary Agents

```JavaScript
function binaryAgent(str) {
  const binary = [128, 64, 32, 16, 8, 4, 2, 1];
  return str.split(' ').map(value => String.fromCharCode(value.split('')
    .reduce((prev, cur, index) => parseInt(prev + (cur * binary[index]), 10)))).join('');
}

/* eslint-disable */
console.log(binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111")); // should return "Aren't bonfires fun!?"
console.log(binaryAgent("01001001 00100000 01101100 01101111 01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001")); // should return "I love FreeCodeCamp!"
```

I create an array `binary`, which stores numbers which will help create a character from an 8-bit binary number. Starting off, the passed string `str` is split using the the `split()` method at each space to create an array 8-bit binary numbers/character sets. I then use the `map()` method to iterate through this array. I use the `reduce()` method to create a single value from each binary set using the `binary` array previously. I take the current value `cur` and multiply its relative value in the `binary` array using the current value's index on the `binary` array and then add the previous value `prev`. Once the `reduce()` method has iterated through each of the values in the current set I am left with a single number that I then convert into a character.

This process is repeated for each binary set, until a full sentence is created from the passed string `str`; which is then returned.

OLD SOLUTION:

```JavaScript
function binaryAgent(str) {
  const binary = [128, 64, 32, 16, 8, 4, 2, 1];
  return str.split(' ').map((value) => {
    let sum = 0;
    for (let i = 0; i < value.length; i += 1) {
      sum += value.charAt(i) * binary[i];
    }
    return String.fromCharCode(sum);
  }).join('');
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/binary-agents-revised-old.js#L1)***

*I have an **even** older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/binary-agents-old.js#L1)***

---

## Everything Be True

```JavaScript
function truthCheck(collection, pre) {
  return collection.every(value => value[pre]);
}

/* eslint-disable */
console.log(truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex")); // should return true.
console.log(truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex")); // should return false.
console.log(truthCheck([{"user": "Tinky-Winky", "sex": "male", "age": 0}, {"user": "Dipsy", "sex": "male", "age": 3}, {"user": "Laa-Laa", "sex": "female", "age": 5}, {"user": "Po", "sex": "female", "age": 4}], "age")); // should return false.
console.log(truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true}, {"name": "FastFoward", "onBoat": null}], "onBoat")); // should return false
console.log(truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true, "alias": "Repete"}, {"name": "FastFoward", "onBoat": true}], "onBoat")); // should return true
console.log(truthCheck([{"single": "yes"}], "single")); // should return true
console.log(truthCheck([{"single": ""}, {"single": "double"}], "single")); // should return false
console.log(truthCheck([{"single": "double"}, {"single": undefined}], "single")); // should return false
console.log(truthCheck([{"single": "double"}, {"single": NaN}], "single")); // should return false
```

There really is not much to explain for this solution. I use the `every()` method to check if the predicate (the second argument) is `truthy` on all elements of a collection (the first argument).

I feel something might have changed or I just simply overthought my previous solution.

OLD SOLUTION:

```JavaScript
function truthCheck(collection, pre) {
  return collection.every(value => !!value[pre]);
}
```

While in this case, it is unnecessary to use two logical NOT (`!`) operators, I still can learn from my mistake in this previous solution; and see benefits where using two logical NOTs in a row like this would be useful.

The logical NOT (`!`) converts a non-boolean response into a response that is boolean. So adding on a second logical NOT (`!!`) means that I converting my response to a boolean and then inverting that response.

Looking more into this... it seems that this is just a, probably terrible, way to do a type conversion or type casting.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/everything-be-true-old.js#L1)***

---

## Arguments Optional

```JavaScript
function addTogether() {
  const args = Array.from(arguments);

  if (args.every(value => typeof value === 'number')) {
    if (args.length > 1) {
      return args.reduce((prev, cur) => prev + cur);
    }
    return (argTwo => (typeof argTwo === 'number' ? argTwo + args[0] : undefined));
  }
  return undefined;
}

/* eslint-disable */
console.log(addTogether(2, 3)); // should return 5.
console.log(addTogether(2)(3)); // should return 5.
console.log(addTogether("http://bit.ly/IqT6zt")); // should return undefined.
console.log(addTogether(2, "3")); // should return undefined.
console.log(addTogether(2)([3])); // should return undefined.
```

Similar to my previous solution, I tried to clean it up a bit. I create a variable `args` which holds any number of arguments passed. This is to solve the first test-case in which passes both arguments at once `addTogether(2, 3)`. I then check if every value in this `args` variable is a number using the `every()` method. If every value is in-fact a number I then check the length of the `args` variable, and if it is greater than 1, I return the sum of the passed arguments in the `args` variable.

If every value in the `args` array is a number, but the length is less than 1: I return an anonymous function that checks the type of this second argument that is being passed to this anonymous function. If this second argument is  a number I return the first value in the `args` array plus this second argument. If the second argument is not a number then I return `undefined`.

Finally, if every value in the `args` array is not a number I simply return `undefined`.

```JavaScript
function addTogether() {
  const args = Array.from(arguments);
  if (typeof args[0] === 'number') {
    if (typeof args[1] === 'number') {
      return args[0] + args[1];
    } else if (!args[1]) {
      return (value) => {
        if (typeof value === 'number') {
          return args[0] + value;
        }
        return undefined;
      };
    }
  }
  return undefined;
}
```

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/arguments-optional-old.js#L1)***

---

## Make a Person

```JavaScript
const Person = function (firstAndLast) {
  let fullName = firstAndLast;

  this.getFirstName = function () {
    return fullName.split(' ')[0];
  };

  this.getLastName = function () {
    return fullName.split(' ')[1];
  };

  this.getFullName = function () {
    return fullName;
  };

  this.setFirstName = function (first) {
    fullName = `${first} ${fullName.split(' ')[1]}`;
  };

  this.setLastName = function (last) {
    fullName = `${fullName.split(' ')[0]} ${last}`;
  };

  this.setFullName = function (firstAndLast) {
    fullName = firstAndLast;
  };
};

const bob = new Person('Bob Ross');

/* eslint-disable */
console.log(Object.keys(bob).length); // should return 6.
console.log(bob instanceof Person); // should return true.
console.log(bob.firstName); // should return undefined.
console.log(bob.lastName); // should return undefined.
console.log(bob.getFirstName()); // should return "Bob".
console.log(bob.getLastName()); // should return "Ross".
console.log(bob.getFullName()); // should return "Bob Ross".
console.log(bob.getFullName()); // should return "Haskell Ross" after bob.setFirstName("Haskell").
console.log(bob.getFullName()); // should return "Haskell Curry" after bob.setLastName("Curry").
console.log(bob.getFullName()); // should return "Haskell Curry" after bob.setFullName("Haskell Curry").
console.log(bob.getFirstName()); // should return "Haskell" after bob.setFullName("Haskell Curry").
console.log(bob.getLastName()); // should return "Curry" after bob.setFullName("Haskell Curry").
```

This challenge is all about teaching how to create a simple object that is representing a 'person'.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/make-a-person-revised-old.js#L1)***

*I have an **even** older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/make-a-person-old.js#L1)***

---

## Map the Debris

```JavaScript
function orbitalPeriod(arr) {
  const GM = 398600.4418;
  const earthRadius = 6367.4447;
  const array = [];

  arr.forEach((value) => {
    array.push({ name: value.name, orbitalPeriod: Math.round(2 * Math.PI * Math.sqrt(Math.pow(earthRadius + value.avgAlt, 3) / GM)) });
  });

  return array;
}

/* eslint-disable */
console.log(orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}])); // should return [{name: "sputnik", orbitalPeriod: 86400}].
console.log(orbitalPeriod([{name: "iss", avgAlt: 413.6}, {name: "hubble", avgAlt: 556.7}, {name: "moon", avgAlt: 378632.553}])); // should return [{name : "iss", orbitalPeriod: 5557}, {name: "hubble", orbitalPeriod: 5734}, {name: "moon", orbitalPeriod: 2377399}].
```

The hardest part about this challenge was making sure the equation was being calculated correctly. 

I used the `forEach()` method to `push()` the names of various 'debris' and their calculated orbital periods as objects being pushed into an array, and then returning that array.

*I have an older version of this challenge: **[View Here](https://github.com/Squibs/freeCodeCamp/blob/master/2.%20JavaScript%20Algorithms%20and%20Data%20Structures/Legacy%20Algorithm%20Files%20and%20Notes/Intermediate%20Algorithm%20Scripting/map-the-debris-old.js#L1)***
