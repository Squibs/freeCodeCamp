# React

List of sections:

- [Introduction to the React Challenges](#introduction-to-the-react-challenges)
- [Create a Simple JSX Element](#create-a-simple-jsx-element)
- [Create a Complex JSX Element](#create-a-complex-jsx-element)
- [Add Comments in JSX](#add-comments-in-jsx)
- [Render HTML Elements to the DOM](#render-html-elements-to-the-dom)
- [Define an HTML Class in JSX](#define-an-html-class-in-jsx)
- [Learn About Self-Closing JSX Tags](#learn-about-self-closing-jsx-tags)
- [Create a Stateless Functional Component](#create-a-stateless-functional-component)
- [Create a Component with React](#create-a-component-with-react)
- [Create a Component with Composition](#create-a-component-with-composition)
- [Use React to Render Nested Components](#use-react-to-render-nested-components)
- [Compose React Components](#compose-react-components)
- [Render a Class Component to the DOM](#render-a-class-component-to-the-dom)
- [Write a React Component from Scratch](#write-a-react-component-from-scratch)
- [Pass Props to a Stateless Functional Component](#pass-props-to-a-stateless-functional-component)
- [Pass an Array as Props](#pass-an-array-as-props)
- [Use Default Props](#use-default-props)
- [Override Default Props](#override-default-props)
- [Use PropTypes to Define the Props You Expect](#use-proptypes-to-define-the-props-you-expect)
- [Access Props Using this.props](#access-props-using-thisprops)
- [Using Props with Stateless Functional Components](#using-props-with-stateless-functional-components)
- [Create a Stateful Component](#create-a-stateful-component)
- [Render State in the User Interface](#render-state-in-the-user-interface)
- [Render State in the User Interface Another Way](#render-state-in-the-user-interface-another-way)
- [Set State with this.setState](#set-state-with-thissetstate)
- [Bind 'this' to a Class Method](#bind-this-to-a-class-method)
- [Bind 'this' with an ES6 Arrow Function](#bind-this-with-an-es6-arrow-function)
- [Use State to Toggle an Element](#use-state-to-toggle-an-element)
- [Write a Simple Counter](#write-a-simple-counter)
- [Create a Controlled Input](#create-a-controlled-input)
- [Create a Controlled Form](#create-a-controlled-form)
- [Pass State as Props to Child Components](#pass-state-as-props-to-child-components)
- [Pass a Callback as Props](#pass-a-callback-as-props)
- [Use the Lifecycle Method componentWillMount](#use-the-lifecycle-method-componentwillmount)
- [Use the Lifecycle Method compnenentDidMount](#use-the-lifecycle-method-compnenentdidmount)
- [Add Event Listeners](#add-event-listeners)
- [Manage Updates with Lifecycle Methods](#manage-updates-with-lifecycle-methods)
- [Optimize Re-Renders with shouldComponentUpdate](#optimize-re-renders-with-shouldcomponentupdate)
- [Introducing Inline Styles](#introducing-inline-styles)
- [Add Inline Styles in React](#add-inline-styles-in-react)
- [Use Advanced JavaScript in React Render Method](#use-advanced-javascript-in-react-render-method)
- [Render with an If/Else Condition](#render-with-an-ifelse-condition)
- [Use && for a More Concise Conditional](#use--for-a-more-concise-conditional)
- [Return null to Prevent Rendering](#return-null-to-prevent-rendering)
- [Use a Ternary Expression for Conditional Rendering](#use-a-ternary-expression-for-conditional-rendering)
- [Render Conditionally from Props](#render-conditionally-from-props)
- [Change Inline CSS Conditionally Based on Component State](#change-inline-css-conditionally-based-on-component-state)
- [Use Array.map() to Dynamically Render Elements](#use-arraymap-to-dynamically-render-elements)
- [Give Sibling Elements a Unique Key Attribute](#give-sibling-elements-a-unique-key-attribute)
- [Use Array.filter() to Dynamically Filter an Array](#use-arrayfilter-to-dynamically-filter-an-array)
- [Render React on the Server with renderToString](#render-react-on-the-server-with-rendertostring)

---

## Introduction to the React Challenges

(Challenges are in an alpha stage at this point. I will be doing these challenges at http://hysterical-amusement.surge.sh/ ) ~ *challenges are no longer in an alpha state; they are now on the beta of freeCodeCamp.*

React is an Open Source view library created and maintained by Facebook. It's a great tool to render the User interface (UI) of modern web applications.

React uses a syntax extension of JavaScript called JSX (JavaScript XML (eXtensible Markup Language)) that allows you to write HTML directly within JavaScript. This has several benefits; it lets you use the full programmatic power of JavaScript within HTML, and helps to keep your code readable. JSX is mostly similar to the HTML you have already learned, however there are a few key differences that will be covered in these challenges.


**JSX must be compiled/transpiled into JavaScript**, because JSX is not valid JavaScript. ***Babel*** is a popular tool for this process.

---

## Create a Simple JSX Element

```JSX
const JSX = <h1>Hello JSX!</h1>;
```

This is a basic example of JSX, storing an html element inside of a JavaScript variable.

---

## Create a Complex JSX Element

```JSX
const JSX = (
  <div>
    <h1>This is a heading.</h1>
    <p>This is a paragraph:</p>
    <ul>
      <li>List item #1</li>
      <li>List item #2</li>
      <li>List item #3</li>
    </ul>
  </div>
);
```

Nested JSX **must return a single element**.

For Example; this is valid JSX:

```HTML
<div>
  <p>Paragraph One</p>
  <p>Paragraph Two</p>
  <p>Paragraph Three</p>
</div>
```

While this is invalid JSX:

```HTML
<p>Paragraph One</p>
<p>Paragraph Two</p>
<p>Paragraph Three</p>
```

---

## Add Comments in JSX

```JSX
const JSX = (
  <div>
    {/* this is a JSX comment */}
    <h1>This is a block of JSX</h1>
    <p>Here's a subtitle</p>
  </div>
);
```

Comments in JSX are put in via `{/* */}`.

---

## Render HTML Elements to the DOM

```JSX
const JSX = (
  <div>
    <h1>Hello World</h1>
    <p>Lets render this to the DOM</p>
  </div>
);
// change code below this line

ReactDOM.render(JSX, document.getElementById('challenge-node'));
```

This lesson on beta freeCodeCamp is able to render the JSX I am typing directly to the HTML DOM using React's rendering API known as ReactDOM.

ReactDOM offers a simple method to render React elements to the DOM which looks like: `ReactDOM.render(componentToRender, targetNode)`.

`ReactDOM.render()` must be called after the JSX element declarations, just like how you must declare variables before using them.

---

## Define an HTML Class in JSX

```JSX
const JSX = (
  <div className="myDiv">
    <h1>Add a class to this div</h1>
  </div>
);
```

You can no longer use the word `class` to define HTML classes in JSX. `class` is a reserved word in JavaScript. 

Instead JSX uses `className`. **The naming convention for all HTML attributes and event references in JSX become *camelCase***.

---

## Learn About Self-Closing JSX Tags

```JSX
const JSX = (
  <div>
    {/* change code below this line */}

    <h2>Welcome to React!</h2> <br />
    <p>Be sure to close all tags!</p>
    <hr />

    {/* change code above this line */}
  </div>
);

// ReactDOM.render(JSX, document.getElementById('challenge-node'));
```

All tags must be closed in JSX. A line-break tag `<br>` must be written as `<br/>`.

A `<div>` can be written as `<div/>` which allows the use of a `div` *without* having to include child elements.

---

## Create a Stateless Functional Component

```JSX
const MyComponent = function () {
  // change code below this line

  return (
    <div>Some string of text.</div>
  );

  // change code above this line
};
```

Components are the core of React. **Everything in React is a component**.

There are two ways to create a React component. The first way is via a JavaScript function; defining a component in this way creates a *stateless funcitonal componenet*. The concept of state in an application will be covered in a later challenge.

For now think of a stateless component as one that can receive data and render it, but does not manage or track changes to that data. (The second way to create a React component will be covered in the next challenge).

**React requires your function name to begin with a capital letter.**

---

## Create a Component with React

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  
  render() {
    // change code below this line

    return (
      <div>
        <h1>Hello React!</h1>
      </div>
    );

    // change code above this line
  }
};
```

The second way to define a React component is with the ES6 `class` syntax.

Extending the `React.Component` class is what will provide many useful React features to this `MyComponent` class (such as local state and lifecycle hooks).

The `MyComponent` class also has a `constructor` that calls `super()`. It uses `super()` to cal the constrcutor of the parent class (`React.Component`). The constructor is a special method used during the initialization of objects that are craeted with the `class` keyword.

It is best practice to call a component's `constructor` with `super` and pass `props` to both. This makes sure the component is initialized properly. For now, know that it is standard for this code to be included. Soon you will see other uses for the constructor as well as `props`.

---

## Create a Component with Composition

```JSX
const ChildComponent = () => (
  <div>
    <p>I am the child</p>
  </div>
);

class ParentComponent extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>I am the parent</h1>
        { /* change code below this line */ }

        <ChildComponent />
        
        { /* change code above this line */ }
      </div>
    );
  }
}
```

Imagine you are building an App and have created three components, a `Navbar`, a `Dashboard`, and a `Footer`. To compose these components together, you could create an `App` *parent* component which renders each of these three components as *children*.

To render a component as a child in a React component, you include the component name written as a custom HTML tag in the JSX. For example, in the `render` method you could write:

```JSX
return (
  <App>
    <Navbar />
    <Dashboard />
    <Footer />
  </App>
);
```

When React encounters a custom HTML tag that references another component (a component wrapped in `< />` like in the above example), it renders the markup for that component in the location of the tag.

---

## Use React to Render Nested Components

```JSX
const TypesOfFruit = () => (
  <div>
    <h2>Fruits:</h2>
    <ul>
      <li>Apples</li>
      <li>Blueberries</li>
      <li>Strawberries</li>
      <li>Bananas</li>
    </ul>
  </div>
);

const Fruits = () => (
  <div>
    { /* change code below this line */ }

    <TypesOfFruit />

    { /* change code above this line */ }
  </div>
);

class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* change code below this line */ }

        <Fruits />

        { /* change code above this line */ }
      </div>
    );
  }
}
```

Component composition is one of React's powerful features. When you work with React, it is important to start thinking about your user interface in terms of components like the App example in the last challenge.

Break down the UI into its basic building blocks, and those pieces become the components. This helps separate the code responsible for the UI from the code responsible for handling your application logic. This can help simplify the development and maintenance of complex projects.

---

## Compose React Components

```JSX
class Fruits extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h2>Fruits:</h2>
        { /* change code below this line */ }

        <NonCitrus />
        <Citrus />

        { /* change code above this line */ }
      </div>
    );
  }
}

class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* change code below this line */ }

        <Fruits />

        { /* change code above this line */ }
        <Vegetables />
      </div>
    );
  }
}
```

As the challenges continue to use more complex compositions with React components and JSX, there is one important point to note. Rendering ES6 style class components within other components is no different than rendering the simple components you used in the last few challenges.

You can render JSX elements, stateless functional components, and ES6 class components within other components.

---

## Render a Class Component to the DOM

```JSX
class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        {/* change code below this line */}

        <Fruits />
        <Vegetables />

        {/* change code above this line */}
      </div>
    );
  }
}

// change code below this line
ReactDOM.render(<TypesOfFood />, document.getElementById('challenge-node'));
```

The process for rendering React components looks very similar to the way in which JSX elements are rendered using the ReactDOM API (`ReactDOM.render(variableOfComponentToRender, targetNode)`).

In order to render React components you pass the component name in the same way as if you were rendering a nested component, for example `ReactDOM.render(<ComponentToRender />, targetNode)`. This syntax is used for both ES6 class components and functional components.

---

## Write a React Component from Scratch

```JSX
// change code below this line
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>My First React Component!</h1>
      </div>
    );
  }
}

ReactDOM.render(<MyComponent />, document.getElementById('challenge-node'));
```

React components are the core building blocks of React applications so it's important to become very familiar with writing them.

---

## Pass Props to a Stateless Functional Component

```JSX
const CurrentDate = props => (
  <div>
    { /* change code below this line */ }

    <p>The current date is: {props.date}</p>

    { /* change code above this line */ }
  </div>
);

class Calendar extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h3>What date is it?</h3>
        { /* change code below this line */ }

        <CurrentDate date={Date()} />

        { /* change code above this line */ }
      </div>
    );
  }
}
```
*`Date()` is an object in JavaScript that can pull the current date; for example:*

```JavaScript
Date();
// returns "Mon Mar 19 2018 14:11:38 GMT-0600 (Mountain Daylight Time)"
```

In React, you can pass properties to child components. Say you have an `App` component which renders a child component called `Welcome` that is a stateless functional component. You can pass `Welcome` a `user` property by writing:

```JSX
<App>
  <Welcome user="Mark" />
</App>
```

You use **custom HTML attributes** that React provides support for to pass the property `user` to the component `Welcome`. Since `Welcome` is a stateless functional component, it has access to this value like so: `const Welcome = props => <h1>Hello, {props.user}!</h1>;`.

It is standard to call this value `props` and when dealing with stateless functional components, you basically consider it as an argument to a function which returns JSX. You can access the value of the argument in the function body. With class components, you will see this is a little different.

---

## Pass an Array as Props

```JSX
const List = (props) => {
  { /* change code below this line */ }

  return <p>{props.tasks.join(', ')}</p>;

  { /* change code above this line */ }
};

class ToDo extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>To Do Lists</h1>
        <h2>Today</h2>
        { /* change code below this line */ }

        <List tasks={['learn more react', 'learn redux']} />
        <h2>Tomorrow</h2>
        <List tasks={['eat pancakes', 'finish freeCodeCamp', 'take over the world']} />

        { /* change code above this line */ }
      </div>
    );
  }
}
```

To pass an array to a JSX element, it must be treated as JavaScript and wrapped in curly boys.

```JSX
<ParentComponent>
  <ChildComponent colors={["green", "blue", "red"]} />
</ParentComponent>
```

The child component then will have access to the array property `colors`. Array methods such as `join()` can be used when accessing the property.

`const ChildComponent = props => <p>{props.colors.join(', ')}</p>;`

This will join all `colors` array items into a comma separated string and produce:

`<p>green, blue, red</p>`

---

## Use Default Props

```JSX
const ShoppingCart = props => (
  <div>
    <h1>Shopping Cart Component</h1>
  </div>
);

// change code below this line
ShoppingCart.defaultProps = { items: 0 };
```

React has an option to set default props. You assign default props to a component as a property on the component itself and React assigns the default prop if necessary. This allows you to specify what a prop value should be if no value is explicitly provided.

---

## Override Default Props

```JSX
const Items = props => (
  <h1>Current Quantity of Items in Cart: {props.quantity}</h1>
);

// default is declared
Items.defaultProps = {
  quantity: 0,
};

class ShoppingCart extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    { /* change code below this line */ }

    return <Items quantity={10} />;

    { /* change code above this line */ }
  }
}
```

The default property values can be overridden by simply passing a value for that property.

---

## Use PropTypes to Define the Props You Expect

```JSX
const Items = props => (
  <h1>Current Quantity of Items in Cart: {props.quantity}</h1>
);

// change code below this line

Items.propTypes = { quantity: PropTypes.number.isRequired };

// change code above this line

Items.defaultProps = {
  quantity: 0,
};

class ShoppingCart extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return <Items />;
  }
}
```

React provides useful type-checking features to verify that components receive props of the correct type. For example you can set `propTypes` on your component to require the data to be of type `array`. This will throw a useful warning when the data is of any other type.

Best practice is to set `propTypes` when you know the type of a prop ahead of time. `propTypes` are defined the same way in which `defaultProps` are defined.

**As of React v15.5.0, `PropTypes` is imported independently from React, like this:**

```import React, { PropTypes } from `react`;```

---

## Access Props Using this.props

```JSX
class ReturnTempPassword extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        { /* change code below this line */ }

        <p>Your temporary password is: <strong>{ this.props.tempPassword }</strong></p>

        { /* change code above this line */ }
      </div>
    );
  }
}

class ResetPassword extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h2>Reset Password</h2>
        <h3>We've generated a new temporary password for you.</h3>
        <h3>Please reset this password from your account settings ASAP.</h3>
        { /* change code below this line */ }

        <ReturnTempPassword tempPassword={'thisisyourtemppasswordverysecure'} />

        { /* change code above this line */ }
      </div>
    );
  }
}
```

Similar to ES6 classes, only... you can access the property via `this.prop.myProperty`.

---

## Using Props with Stateless Functional Components

```JSX
class CampSite extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <Camper />
      </div>
    );
  }
}

// change code below this line
const Camper = props => (
  <div>
    <h1>Your Name:</h1>
    <p>{props.name}</p>
  </div>
);


Camper.defaultProps = {
  name: 'CamperBot',
};

Camper.propTypes = {
  name: PropTypes.string.isRequired,
};
```

*It seems this challenge can't handle trailing commas for `defaultProps` & `propTypes`*.

A review of the terminology for components:

- A *stateless functional component* is any function you write which accepts props and returns JSX.

- A *stateless component* is a class that extends `React.Component`, but does not use internal state(covered in the next challenge).

- A *stateful component* is any component that does maintain its own internal state. You may see stateful components referred to simply as components or React components.

A common pattern is to try to minimize statefulness and to create stateless functional components wherever possible. This helps contain your management to a specific area of your application. In turn, this improves development and maintenance of your app by making it easier to follow how changes to state affect its behavior.

---

## Create a Stateful Component

```JSX
class StatefulComponent extends React.Component {
  constructor(props) {
    super(props);

    // initialize state here
    this.state = {
      name: 'Zachary Holman',
    };
  }

  render() {
    return (
      <div>
        <h1>{this.state.name}</h1>
      </div>
    );
  }
}
```

One of the most important topics in React is `state`. State consists of any data your application needs to know about, that can change over time. You want your apps to respond to state changes and present an updated UI when necessary. React offers a nice solution for the state management of modern web applications.

You create state in a React component by declaring a `state` property on the component class in its `constructor`. This initializes the component with `state` when it is created. The `state` property must be set to a JavaScript `object`. Declaring it looks like this:

```JSX
this.state = {
  // describe your state here
};
```

Note that you must create a class component by extending `React.Component` in order to create `state` like this.

---

## Render State in the User Interface

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'Free Code Camp',
    };
  }

  render() {
    return (
      <div>
        { /* change code below this line */ }

        <h1>{this.state.name}</h1>

        { /* change code above this line */ }
      </div>
    );
  }
}
```

React uses what is called a virtual DOM. If data changes, your UI will change. When state data updates, it triggers a re-render of the components using that data - including child components that received the data as a prop. React updates the actual DOM, but only where necessary. This means that you don't have to worry about changing the DOM. You simply declare what the UI should look like.

Note that if you make a component stateful, no other components are aware of its `state`. Its `state` is completely encapsulated, or local to that component, unless you pass state data to a child component as `props`. This notion of encapsulated `state` is very important because it allows you to write certain logic, then have that logic contained and isolated in one place in your code.

---

## Render State in the User Interface Another Way

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'Free Code Camp',
    };
  }

  render() {
    // change code below this line

    const name = this.state.name;

    // change code above this line
    return (
      <div>
        { /* change code below this line */ }

        <h1>{name}</h1>

        { /* change code above this line */ }
      </div>
    );
  }
}
```

You can set a state, or possibly even a property, to a normal JavaScript variable and use that variable instead of the state / prop.

---

## Set State with this.setState

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'Initial State',
    };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // change code below this line

    this.setState({ name: 'React Rocks!' });

    // change code above this line
  }

  render() {
    return (
      <div>
        <button onClick={this.handleClick}>Click Me</button>
        <h1>{this.state.name}</h1>
      </div>
    );
  }
}
```

React provides a method for updating component `state` called `setState`. You call the `setState` method within your component class like so: `this.setState()`, passing an object with key-value pairs. The keys are your state properties and the values are the updated state data.

For instance, if we were storing a `username` in state and wanted to update it, it would look like this:

```JSX
this.setState({
  username: 'Lewis'
});
```

React expects you to never modify `state` directly, instead always use `this.setState()` when state changes occur.

Also, you should note that React may batch multiple state updates in order to improve performance. What this means is that state updates through the `setState` method can be asynchronous. There is an alternative syntax for the `setState` method which provides a way around this problem. This is rarely needed but it's good to keep in mind! Please consult the [React documentation](https://facebook.github.io/react/docs/state-and-lifecycle.html) for further details.

---

## Bind 'this' to a Class Method

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      itemCount: 0,
    };
    // change code below this line

    this.addItem = this.addItem.bind(this);

    // change code above this line
  }

  addItem() {
    this.setState({
      itemCount: this.state.itemCount + 1,
    });
  }

  render() {
    return (
      <div>
        { /* change code below this line */ }

        <button onClick={this.addItem}>Click Me</button>

        { /* change code above this line */ }
        <h1>Current Item Count: {this.state.itemCount}</h1>
      </div>
    );
  }
}
```

I learned about this while doing the advanced front end projects. You basically state what you want `this` to be.

In this example `this.addItem = this.addItem.bind(this);` is setting `this` to be the `MyComponent` class rather than the `addItem()` function. Before `this` is bound, calling `this` inside the `addItem()` function would refer to the function itself, rather than the `MyComponent` class.

---

## Bind 'this' with an ES6 Arrow Function

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    
    // change code below this line
    
    this.state = {
      message: 'Hello!',
    };

    // change code above this line
  }

  // change code below this line

  setMessage = () => {
    this.setState({
      message: 'Goodbye!'
    });
  }

  // change code above this line

  render() {
    return (
      <div>
        <button onClick = {this.setMessage}>Click Me</button>
        <h1>{this.state.message}</h1>
      </div>
    );
  }
};
```

**This challenge/lesson is no longer available moving from the alpha site to beta freeCodeCamp; leaving it here for posterity.**

If you are using ESLint and run into the error `Parsing error: Unexpected token =` I stumbled on the answer/solution while trying to figure out why I was receiving an error for using this syntax [Stack Overflow Solution](https://stackoverflow.com/questions/42701440/eslint-parsing-error-unexpected-token-error-for-assigned-fat-arrow-prop/42701804#42701804).

```
You're using class field (a.k.a. property initializer) syntax, which is not part of ECMAScript 2015 (ES6), nor ES2016 or 2017, and so unsupported by ESLint. It's currently a Stage 2 proposal. If you want to use it with ESLint, you'll need to use babel-eslint.
```
[babel-eslint](https://github.com/babel/babel-eslint) || [Stage 2 proposal](https://github.com/tc39/proposals)

**I'm going to try and remove all instances of the use of this method of binding `this` in the following lessons.**

--

I learned about this method of binding `this` as well from the advanced front end projects. Although I was unsure of the exact details of it.

Using the ES6 arrow function, although it does not assign its own value for `this`, it instead adopts the value of `this` from the context surrounding the function when it is written. In other words, an arrow function binds `this` automatically from its surrounding context.

---

## Use State to Toggle an Element

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      visibility: false,
    };

    // change code below this line

    this.toggleVisibility = this.toggleVisibility.bind(this);

    // change code above this line
  }
  // change code below this line

  toggleVisibility() {
    this.setState({
      visibility: !this.state.visibility,
    });

    // A second method (see notes below):
    // this.setState(prevState => ({
    //   visibility: !prevState.visibility,
    // }));
  }

  // change code above this line
  render() {
    if (this.state.visibility) {
      return (
        <div>
          <button onClick={this.toggleVisibility}>Click Me</button>
          <h1>Now you see me!</h1>
        </div>
      );
    }

    return (
      <div>
        <button onClick={this.toggleVisibility}>Click Me</button>
      </div>
    );
  }
}
```

I stumbled upon a [second way](https://www.reddit.com/r/reactjs/comments/7k3xw4/setstate_with_and_without_arrow_function/) to do the same thing which may or may not have possible side effects. A quick summary:

What is the difference between these two `setState` usage:

```JSX
handleClick() {
    this.setState({
      active: !this.state.active,
    });
}
```

```JSX
handleClick(){
    this.setState(prevState => ({
      active: !prevState.active,
    }));
}
```

Answer:

Use the first form only when setting a value in state to an explicit value:

```JSX
this.setState({
  active: false,
});
```

Use the latter when setting a value in state in a way that relies on the previous value (e.g. toggling a boolean, incrementing a number):

```JSX
this.setState(prevState => ({
  quantity: prevState.quantity + 1,
}));
```

This is the only way you will know for sure that the state is changing is up to date. This matters when using multiple setState functions quickly.

---

## Write a Simple Counter

```JSX
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
    // change code below this line

    this.increment = this.increment.bind(this);
    this.decrement = this.decrement.bind(this);
    this.reset = this.reset.bind(this);

    // change code above this line
  }
  // change code below this line

  increment() {
    this.setState({
      count: this.state.count + 1,
    });
  }

  decrement() {
    this.setState({
      count: this.state.count - 1,
    });
  }

  reset() {
    this.setState({
      count: this.state.count = 0,
    });
  }

  // change code above this line
  render() {
    return (
      <div>
        <button className="inc" onClick={this.increment}>Increment!</button>
        <button className="dec" onClick={this.decrement}>Decrement!</button>
        <button className="reset" onClick={this.reset}>Reset</button>
        <h1>Current Count: {this.state.count}</h1>
      </div>
    );
  }
}
```

You can design a more complex stateful component by combining the concepts covered so far. These include initializing `state`, writing methods that set `state`, and assigning click handlers to trigger these methods.

---

## Create a Controlled Input

```JSX
class ControlledInput extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: '',
    };
    // change code below this line

    this.handleChange = this.handleChange.bind(this);

    // change code above this line
  }
  // change code below this line

  handleChange(event) {
    this.setState({
      input: event.target.value,
    });
  }

  // change code above this line
  render() {
    return (
      <div>
        { /* change code below this line */}

        <input value={this.state.input} onChange={this.handleChange} />

        { /* change code above this line */}
        <h4>Controlled Input:</h4>
        <p>{this.state.input}</p>
      </div>
    );
  }
}
```

An application can have more complex interactions between `state` and the rendered UI.

For example, form control elements for text input, such as `input` and `textarea`, maintain their own state in the DOM as the user types. With React, you can move this mutable state into a React component's `state`. The user's input becomes part of the application `state`, so React controls the value of that input field.

Typically, if you have React components with input fields the user can type into, it will be a controlled input form.

---

## Create a Controlled Form

```JSX
class MyForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: '',
      submit: '',
    };
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({
      input: event.target.value,
    });
  }

  handleSubmit(event) {
    // change code below this line

    event.preventDefault();

    this.setState({
      submit: this.state.input,
    });

    // change code above this line
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          { /* change code below this line */ }

          <input
            value={this.state.input}
            onChange={this.handleChange}
          />

          { /* change code above this line */ }
          <button type="submit">Submit!</button>
        </form>
        { /* change code below this line */ }

        <h1>{this.state.submit}</h1>

        { /* change code above this line */ }
      </div>
    );
  }
}
```

The last challenge showed that React can control the internal state for certain elements like `input` and `textarea`, which makes them controlled components. This applies to other form elements as well, including the regular HTML `form` element.

---

## Pass State as Props to Child Components

```JSX
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'CamperBot',
    };
  }

  render() {
    return (
      <div>
        <Navbar name={this.state.name} />
      </div>
    );
  }
}

class Navbar extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Hello, my name is: { this.props.name } </h1>
      </div>
    );
  }
}
```

A common pattern is to have a stateful component containing the `state` important to your app, that then renders child components. You want these components to have access to some pieces of that `state`, which are passed in as props.

For example, maybe you have an `App` component that renders a `Navbar`, among other components. In your `App`, you have `state` that contains a lot of user information, but the `Navbar` only needs access to the user's username so it can display it. You pass that piece of `state` to the `Navbar` component as a `props`.

This pattern illustrates some important paradigms in React. The first is **unidirectional data flow**. State flows in one direction down the tree of your application's components, from the stateful parent component to child components. The child components only receive the state data they need.

The second is that complex stateful apps can be broken down into just a few, or maybe a single, stateful component. The rest of your components simply receive state from the parent as props, and render a UI from that state. It begins to create a separation where state management is handled in one part of code and UI rendering in another.

This principle of separating state logic from UI logic is one of React's key principles. When it's used correctly, it makes the design of complex, stateful applications much easier to manage.

---

## Pass a Callback as Props

```JSX
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      inputValue: '',
    };
    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(event) {
    this.setState({
      inputValue: event.target.value,
    });
  }

  render() {
    return (
      <div>
        { /* change code below this line */ }

        <GetInput input={this.state.inputValue} handleChange={this.handleChange} />
        <RenderInput input={this.state.inputValue} />

        { /* change code above this line */ }
      </div>
    );
  }
}

class GetInput extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h3>Get Input:</h3>
        <input
          value={this.props.input}
          onChange={this.props.handleChange}
        />
      </div>
    );
  }
}

class RenderInput extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h3>Input Render:</h3>
        <p>{this.props.input}</p>
      </div>
    );
  }
}
```

You can pass handler functions or any method that is defined on a React component to a child component. This is how you allow child components to interact with their parent components. You pass methods to a child just like a regular prop. It's assigned a name and you have access to that method name under `this.props` in the child component.

---

## Use the Lifecycle Method componentWillMount

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }

  componentWillMount() {
    // change code below this line

    console.log('component will mount');

    // change code above this line
  }

  render() {
    return <div />;
  }
}
```

React components have several special methods that provide opportunities to perform actions at specific points in the lifecycle of a component. These are called lifecycle methods, or lifecycle hooks, and allow you to catch components at certain points in time.

This can be before they are rendered, before they update, before they receive props, before they unmount, and so on.

Here is a list of some of the main lifecycle methods:

```JSX
componentWillMount()
componentDidMount()
componentWillReceiveProps()
shouldComponentUpdate()
componentWillUpdate()
componentDidUpdate()
componentWillUnmount() 
```

The `componentWillMount()` method is called before the `render()` method when a component is being mounted to the DOM.

---

## Use the Lifecycle Method compnenentDidMount

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      activeUsers: null,
    };
  }

  componentDidMount() {
    setTimeout(() => {
      this.setState({
        activeUsers: 1273,
      });
    }, 2500);
  }

  render() {
    return (
      <div>
        <h1>Active Users: { this.state.activeUsers }</h1>
      </div>
    );
  }
}
```

*There is a mock API call in `componentDidMount()`; it sets state after 2.5 seconds to simulate calling a server to retrieve data.*

Most web developers, at some point, need to call an API endpoint to retrieve data. If you're working with React, it's important to know where to perform this action.

The best practice with React is to place API calls or any calls to your server in the lifecycle method `componentDidMount()`. This method is called after a component is mounted to the DOM. Any calls to `setState()` here will trigger a re-rendering of your component. When you call an API in this method, and set your state with the data that the API returns, it will automatically trigger an update once you receive the data.

---

## Add Event Listeners

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: '',
    };
    this.handleEnter = this.handleEnter.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
  }

  // change code below this line

  componentDidMount() {
    document.addEventListener('keydown', this.handleKeyPress);
  }

  componentWillUnmount() {
    document.removeEventListener('keydown', this.handleKeyPress);
  }

  // change code above this line

  handleEnter() {
    this.setState({
      message: `${this.state.message}You pressed the enter key! `,
    });
  }

  handleKeyPress(event) {
    if (event.keyCode === 13) {
      this.handleEnter();
    }
  }

  render() {
    return (
      <div>
        <h1>{this.state.message}</h1>
      </div>
    );
  }
}
```

**The `componentDidMount()` method is also the best place to attach any event listeners you need to add for specific functionality.**

React provides a synthetic event system which wraps the native event system present in browsers. This means that the synthetic event system behaves exactly the same regardless of the user's browser - even if the native events may behave differently between different browsers.

In this example an event listener is being added in the `componentDidMount()` method and then is being removed in the `componentWillUnMount()` method. It is good practice to use this lifecycle method to do any clean up on React components before they are unmounted and destroyed. Removing event listeners is an example of one such clean up action.

---

## Manage Updates with Lifecycle Methods

```JSX
class Dialog extends React.Component {
  constructor(props) {
    super(props);
  }

  // should be below componentWillReceiveProps
  componentWillUpdate() {
    console.log('Component is about to update...');
  }

  // change code below this line

  componentWillReceiveProps(nextProps) {
    console.log(this.props, nextProps);
  }

  componentDidUpdate() {
    console.log('Component is now updated!');
  }

  // change code above this line

  render() {
    return <h1>{this.props.message}</h1>;
  }
}

class Controller extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: 'First Message',
    };
    this.changeMessage = this.changeMessage.bind(this);
  }

  changeMessage() {
    this.setState({
      message: 'Second Message',
    });
  }

  render() {
    return (
      <div>
        <button onClick={this.changeMessage}>Update</button>
        <Dialog message={this.state.message} />
      </div>
    );
  }
}
```

Another lifecycle method is `componentWillReceiveProps()` which is called whenever a component is receiving new props. This method receives the new props as an argument, which is usually written as `nextProps`. You can use this argument and compare with `this.props` and perform actions before the component updates. For example, you may call `setState()` locally before the update is processed.

Another method is `componentDidUpdate()`, and is called immediately after a component re-renders. Note that rendering and mounting are considered different things in the component lifecycle. When a page first loads, all components are mounted and this is where methods like `componentWillMount()` and `componentDidMount()` are called. After this, as state changes, components re-render themselves.

---

## Optimize Re-Renders with shouldComponentUpdate

```JSX
class OnlyEvens extends React.Component {
  constructor(props) {
    super(props);
  }

  // should be placed after componentWillReceiveProps
  shouldComponentUpdate(nextProps, nextState) {
    console.log('Should I update?');
    // change code below this line

    if (nextProps.value % 2 === 0) {
      return true;
    }
    return false;

    // change code above this line
  }

  componentWillReceiveProps(nextProps) {
    console.log('Receiving new props...');
  }

  componentDidUpdate() {
    console.log('Component re-rendered.');
  }

  render() {
    return <h1>{this.props.value}</h1>;
  }
}

class Controller extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 0,
    };
    this.addValue = this.addValue.bind(this);
  }

  addValue() {
    this.setState({
      value: this.state.value + 1,
    });
  }

  render() {
    return (
      <div>
        <button onClick={this.addValue}>Add</button>
        <OnlyEvens value={this.state.value} />
      </div>
    );
  }
}
```

So far, if any component receives new `state` or new `props`, it re-renders itself and all its children. This is usually okay. But React provides a lifecycle method you can call when child components receive new `state` or `props`, and declare specifically if the components should update or not.

The method is `shouldComponentUpdate()`, and it takes `nextProps` and `nextState` as parameters.

This method is a useful way to optimize performance. For example, the default behavior is that your component re-renders when it receives new `props`, even if the `props` haven't changed. You can use `shouldComponentUpdate()` to prevent this by comparing the `props`. The method must return a `boolean` value that tells React whether or not to update the component. You can compare the current props (`this.props`) to the next props (`nextProps`) to determine if you need to update or not, and return `true` or `false` accordingly.

---

## Introducing Inline Styles

```JSX
class Colorful extends React.Component {
  render() {
    return (
      <div style={{ color: 'red', fontSize: '72px' }}>Big Red</div>
    );
  }
}
```

You apply inline styles to JSX elements similar to how you do it in HTML, but with a few JSX differences. Here's an example of an inline style in HTML:

`<div style="color: yellow; font-size: 16px">Mellow Yellow</div>`

JSX elements use the `style` attribute, but because of the way JSX is transpiled, you can't set the value to a `string`. Instead, you set it equal to a JavaScript `object`. Here's an example:

`<div style={{color: 'yellow', fontSize: '16px'}}>Mellow Yellow</div>`

---

## Add Inline Styles in React

```JSX
const styles = {
  color: 'purple',
  fontSize: 40,
  border: '2px solid purple',
};
// change code above this line

class Colorful extends React.Component {
  render() {
    // change code below this line

    return (
      <div style={styles}>Style Me!</div>
    );

    // change code above this line
  }
}
```

**Hyphenated style properties such as (`font-size`) in are written using camelCase in JSX (`fontSize`).**

All property value length units (like `height`, `width`, and `fontSize`) are assumed to be in `px` unless otherwise specified. If you want to use `em`, for example, you wrap the value and the units in quotes, like `{fontSize: '4em'}`. Other than the length values that default to `px`, all other property values should be wrapped in quotes.

---

## Use Advanced JavaScript in React Render Method

```JSX
const inputStyle = {
  width: 235,
  margin: 5,
};

class MagicEightBall extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userInput: '',
      randomIndex: '',
    };
    this.ask = this.ask.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }

  ask() {
    if (this.state.userInput) {
      this.setState({
        randomIndex: Math.floor(Math.random() * 20),
        userInput: '',
      });
    }
  }

  handleChange(event) {
    this.setState({
      userInput: event.target.value,
    });
  }

  render() {
    const possibleAnswers = [
      'It is certain',
      'It is decidedly so',
      'Without a doubt',
      'Yes, definitely',
      'You may rely on it',
      'As I see it, yes',
      'Outlook good',
      'Yes',
      'Signs point to yes',
      'Reply hazy try again',
      'Ask again later',
      'Better not tell you now',
      'Cannot predict now',
      'Concentrate and ask again',
      'Don\'t count on it',
      'My reply is no',
      'My sources say no',
      'Most likely',
      'Outlook not so good',
      'Very doubtful',
    ];

    const answer = possibleAnswers[this.state.randomIndex]; // << change code here

    return (
      <div>
        <input
          type="text"
          value={this.state.userInput}
          onChange={this.handleChange}
          style={inputStyle}
        /><br />
        <button onClick={this.ask}>Ask the Magic Eight Ball!</button><br />
        <h3>Answer:</h3>
        <p>
          { /* change code below this line */ }

          {answer}

          { /* change code above this line */ }
        </p>
      </div>
    );
  }
}
```

Retrieve random answer by using `this.state.randomIndex` in bracket notation. Display the answer simply by rendering `{answer}` in the `<p>` tag.

---

## Render with an If/Else Condition

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      display: true,
    };
    this.toggleDisplay = this.toggleDisplay.bind(this);
  }

  toggleDisplay() {
    this.setState({
      display: !this.state.display,
    });
  }

  render() {
    // change code below this line

    if (this.state.display) {
      return (
        <div>
          <button onClick={this.toggleDisplay}>Toggle Display</button>
          <h1>Displayed!</h1>
        </div>
      );
    } else {
      return (
        <div>
          <button onClick={this.toggleDisplay}>Toggle Display</button>
        </div>
      );
    }
  }
}
```

*Had to include the `else` to pass this challenge, even though it is unnecessary.*

This is an example of using an `if/else` statement to control the view.

---

## Use && for a More Concise Conditional

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      display: true,
    };
    this.toggleDisplay = this.toggleDisplay.bind(this);
  }

  toggleDisplay() {
    this.setState({
      display: !this.state.display,
    });
  }

  render() {
    // change code below this line

    return (
      <div>
        <button onClick={this.toggleDisplay}>Toggle Display</button>
        { this.state.display && <h1>Displayed!</h1> }
      </div>
    );
  }
}
```

There is a better way to solve the previous challenge. You can use the `&&` logical operator to perform conditional logic in a more concise way. This is possible because you want to check if a condition is `true`, and if it is, return some markup.

Here's an example:

`{ condition && <p>markup</p> }`

If the `condition` is `true`, the markup will be returned. If the condition is `false`, the operation will immediately return `false` after evaluating the `condition` and return nothing. You can include these statements directly in your JSX and string multiple conditions together by writing `&&` after each one. This allows you to handle more complex conditional logic in your `render()` method without repeating a lot of code.

---

## Return null to Prevent Rendering

```JSX
class Parent extends React.Component {
  constructor(props) {
    super(props);
    // change code below this line

    this.state = {
      display: true,
    };

    // change code above this line
    this.submit = this.submit.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }

  toggleDisplay() {
    this.setState({
      display: !this.state.display,
    });
  }

  render() {
    return (
      <div>
        <button onClick={this.toggleDisplay}>Toggle Display</button>
        <Child display={this.state.display} />
      </div>
    );
  }
}

class Child extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    // change code below this line
    return this.props.display ? (<h1>Peek-a-boo!</h1>) : (null);
  }
}
```

**This challenge/lesson is no longer available moving from the alpha site to beta freeCodeCamp; leaving it here for posterity.**

There are situations when you may not want to render a child element. React won't render a component if that component's `render()` method returns `null`. This is useful when you don't want to render components based on conditional logic.

Looks like I skipped a step when doing this... ooops real one should be this instead:

```JSX
render() {
  // change code below this line    
  if (this.props.display) {
    return <h1>Display!</h1>
  } else {
    return null;
  }
}
```

---

## Use a Ternary Expression for Conditional Rendering

```JSX
const inputStyle = {
  width: 235,
  margin: 5,
};

class CheckUserAge extends React.Component {
  constructor(props) {
    super(props);
    // change code below this line

    this.state = {
      input: '',
      userAge: '',
    };

    // change code above this line
    this.submit = this.submit.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(e) {
    this.setState({
      input: e.target.value,
      userAge: '',
    });
  }

  submit() {
    this.setState({
      userAge: this.state.input,
    });
  }

  render() {
    const buttonOne = <button onClick={this.submit}>Submit</button>;
    const buttonTwo = <button>You May Enter</button>;
    const buttonThree = <button>You Shall Not Pass</button>;
    return (
      <div>
        <h3>Enter Your Age to Continue</h3>
        <input
          style={inputStyle}
          type="number"
          value={this.state.input}
          onChange={this.handleChange}
        /><br />
        {
          /* change code here */
          this.state.userAge === '' ?
            buttonOne : this.state.userAge >= 18 ?
              buttonTwo : buttonThree
        }
      </div>
    );
  }
}
```

You can use ternary expressions to render different DOM elements based on various conditions.

---

## Render Conditionally from Props

```JSX
class Results extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>
        {
          /* change code here */
          this.props.fiftyFifty ? 'You win!' : 'You lose!'
        }
      </h1>
    );
  }
}

class GameOfChance extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 1,
    };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState({
      counter: this.state.counter + 1, // change code here
    });
  }

  render() {
    const expression = Math.random() > 0.5;// change code here
    return (
      <div>
        <button onClick={this.handleClick}>Play Again</button>
        { /* change code below this line */ }

        <Results fiftyFifty={expression} />

        { /* change code above this line */ }
        <p>{`Turn: ${this.state.counter}`}</p>
      </div>
    );
  }
}
```

This is an example of a program that generates a random number when a button is clicked and tests whether the player 'wins' or not based on the number generated (50-50 chance). Also has a turn counter.

---

## Change Inline CSS Conditionally Based on Component State

```JSX
class GateKeeper extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: '',
    };
    this.handleInput = this.handleInput.bind(this);
  }

  handleInput(event) {
    this.setState({ input: event.target.value });
  }

  render() {
    const inputStyle = {
      border: '1px solid black',
    };
    // change code below this line

    if (this.state.input.length > 15) {
      inputStyle.border = '3px solid red';
    }

    // change code above this line
    return (
      <div>
        <h3>Don't Type Too Much:</h3>
        <input
          type="text"
          style={inputStyle}
          value={this.state.input}
          onChange={this.handleInput}
        />
      </div>
    );
  }
}
```

This is an example where you can set CSS conditionally based on conditions as well.

---

## Use Array.map() to Dynamically Render Elements

```JSX
const textAreaStyles = {
  width: 235,
  margin: 5,
};

class MyToDoList extends React.Component {
  constructor(props) {
    super(props);
    // change code below this line

    this.state = {
      userInput: '',
      toDoList: [],
    };

    // change code above this line
    this.handleSubmit = this.handleSubmit.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }

  handleSubmit() {
    const itemsArray = this.state.userInput.split(',');
    this.setState({
      toDoList: itemsArray,
    });
  }

  handleChange(e) {
    this.setState({
      userInput: e.target.value,
    });
  }

  render() {
    const items = this.state.toDoList.map(value => <li>{value}</li>); // change code here
    return (
      <div>
        <textarea
          onChange={this.handleChange}
          value={this.state.userInput}
          style={textAreaStyles}
          placeholder="Separate Items With Commas"
        /><br />
        <button onClick={this.handleSubmit}>Create List</button>
        <h1>My "To Do" List:</h1>
        <ul>
          {items}
        </ul>
      </div>
    );
  }
}
```

You may need your components to render an unknown number of elements. Using `Array.map()` in React helps with this problem.

For example, you create a simple "To Do List" app. As the programmer, you have no way of knowing how many items a user might have on their list. You need to set up your component to ***dynamically render*** the correct number of list elements long before someone using the program decides that today is laundry day.

The provided solution has:

```JSX
const items = this.state.toDoList.map((item, i) => {
  return <li key={i}>{item}</li>
});
```

***You may know that all sibling child elements created by a mapping operation like this do need to be supplied with a unique key attribute. Don't worry, this is the topic of the next challenge.***

---

## Give Sibling Elements a Unique Key Attribute

```JSX
const frontEndFrameworks = [
  'React',
  'Angular',
  'Ember',
  'Knockout',
  'Backbone',
  'Vue',
];

function Frameworks() {
  const renderFrameworks = frontEndFrameworks.map((value, index) => <li key={index}>{value}</li>); // change code here
  return (
    <div>
      <h1>Popular Front End JavaScript Frameworks</h1>
      <ul>
        {renderFrameworks}
      </ul>
    </div>
  );
}
```

The last challenge showed how the `map` method is used to dynamically render a number of elements based on user input. 

When you create an array of elements, each one needs a `key` attribute set to a unique value. React uses these keys to keep track of  which items are added changed, or removed. This helps make the re-rendering process more efficient when the list is modified in any way.

Note that keys only need to be unique between sibling elements, they don't need to be globally unique in your application.

**It's a bad idea to use the array index since it doesn't uniquely identify your elements. In cases where the array is sorted or an element is added to the beginning of the array, the index will be changed even though the element representing that index may be the same. This results in unnecessary renders.**

*Normally, you want to make the key something that uniquely identifies the element being rendered. As a last resort the array index may be used, but typically you should try to use a unique identification.*

---

## Use Array.filter() to Dynamically Filter an Array

```JSX
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [
        {
          username: 'Jeff',
          online: true,
        },
        {
          username: 'Alan',
          online: false,
        },
        {
          username: 'Mary',
          online: true,
        },
        {
          username: 'Jim',
          online: false,
        },
        {
          username: 'Sara',
          online: true,
        },
        {
          username: 'Laura',
          online: true,
        },
      ],
    };
  }

  render() {
    const usersOnline = this.state.users.filter(user => user.online); // change code here
    const renderOnline = usersOnline.map((user, key) => <li key={key}>{user.username}</li>); // change code here
    return (
      <div>
        <h1>Current Online Users:</h1>
        <ul>
          {renderOnline}
        </ul>
      </div>
    );
  }
}
```

`filter()` can be used similarly to `map()`.

**It's a bad idea to use the array index since it doesn't uniquely identify your elements. In cases where the array is sorted or an element is added to the beginning of the array, the index will be changed even though the element representing that index may be the same. This results in unnecessary renders.**

*Normally, you want to make the key something that uniquely identifies the element being rendered. As a last resort the array index may be used, but typically you should try to use a unique identification.*

---

## Render React on the Server with renderToString

```JSX
class App extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return <div />;
  }
}

// change code below this line
ReactDOMServer.renderToString(<App />);
```

So far these challenges have been rendering React components on the client, however there are some use cases where it makes sense to render a React component on the server.

Because React is a JavaScript view library and you can run JavaScript on the server with Node, this is possible. React provides a `renderToString()` method you can use for this purpose.

There are two key reasons why rendering on the server may be used in a real world app:

- First, without doing this, your React apps would consist of a relatively empty HTML file and a large bundle of JavaScript when it's initially loaded ot the browser. This may not be ideal for search engines that are trying to index the content of your pages so people can find you. If you render the initial HTML markup on the server and send this to the client, the initial page load contains all of the page's markup which can be crawled by search engines.

- Second, this creates a faster initial page load experience because the rendered HTML is smaller than the JavaScript code of the entire app. React will still be able to recognize your app and manage it after the initial load.
