# Advanced Node and Express

List of Sections:

<!-- TOC -->

- [Set up a Template Engine](#set-up-a-template-engine)
- [Use a Template Engine's Powers](#use-a-template-engines-powers)
- [Set up Passport](#set-up-passport)
- [Serialization of a User Object](#serialization-of-a-user-object)
- [Implement the Serialization of a Passport User](#implement-the-serialization-of-a-passport-user)
- [Authentication Strategies](#authentication-strategies)
- [How to Use Passport Strategies](#how-to-use-passport-strategies)
- [Create New Middleware](#create-new-middleware)
- [How to Put a Profile Together](#how-to-put-a-profile-together)
- [Logging a User Out](#logging-a-user-out)
- [Registration of New Users](#registration-of-new-users)
- [Hashing Your Passwords](#hashing-your-passwords)
- [Clean Up Your Project with Modules](#clean-up-your-project-with-modules)

<!-- /TOC -->

---

## Set up a Template Engine

Template engines enable you to use static template files in your app. At runtime, the engine will replace variables in a template file with actual values which can be supplied by your server. It then transforms the template into a static HTML file that is sent to the client. This makes it easier to design an HTML page and allow for displaying variables on the page without needing to make an API call from the client.

Here we are going to be using `Pug`, express needs to know which template engine you are using. We can use the `set` method to assign `pug` as the `view engine` property's value.

```JavaScript
app.set('view engine', 'pug');
```

We can then `set` the `views` property of our `app` (Express), to point to the `./views/pug` directory. This will tell Express to render all views relative to that directory.

```JavaScript
app.set('views', './views/pug');
```

Then we can use the `res.render` method in a route to render a page. `'index'` here is in reference to the name of the `pug` filename.

```JavaScript
app.get('/', (req, res) => res.render('index'));
```

---

## Use a Template Engine's Powers

One of the best features about using a template engine is the ability to pass variables from the server to the template file before rendering it to HTML.

In `pug` you can use a variable by referencing the variable as `#{variable_name}` inline with other text on an element or by using an equal sign on the element without a space such as `p=variable_name`, which will assign the variable's value to the `p` element's text.

`Pug` is all about using whitespace and tabs to show nested elements and cutting down on the amount of code needed.

```pug
head
  script(type='text/javascript').
    if (foo) bar(1 + 5);
body
  if youAreUsingPug
      p You are amazing
    else
      p Get on it!
```

Which converts to:

```html
<head>
  <script type="text/javascript">
    if (foo) bar(1 + 5);
  </script>
</head>
<body>
  <p>You are amazing</p>
</body>
```

Let's pass the `#title` and `#message` variables to `pug`.

```JavaScript
app.get('/', (req, res) => res.render('index', { title: 'Hello', message: 'Please log in' }));
```

---

## Set up Passport

It is time to set up `Passport` so you can allow a user to register or log in to an account. We will also use Express-session to handle sessions. `Express-session` has a lot of advanced features you can use, but for now we'll use the basics.

Using this middleware saves the session id as a cookie in the client, and allows us to access the session data using that id on the server. This will keep personal account information out of the cookie used by the client to tell the server the clients are authenticated and keep the key to access the data stored on the server.

```JavaScript
const session = require('express-session');
const passport = require('passport');

app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: true,
  saveUninitialized: true,
  cookie: { secure: false },
}));

app.use(passport.initialize());
app.use(passport.session());
```

---

## Serialization of a User Object

Serialization and deserialization are important concepts when it comes to authentication. When you serialize an object you are converting its contents into a small `key` which can then be deserialized into the original object.

We can have a serialize and a deserialize function in passport to do this.

```JavaScript
passport.serializeUser(cb);
passport.deserializeUser(cb);
```

The callback function that is passed to `serializeUser` takes two arguments: the full user object and a callback used by passport. This callback expects two arguments: an error, if one exists, and a unique key to identify the user that should be returned in the callback. With `MongoDB` you'll use the user's `_id` as this is guaranteed to be unique.

`deserializeUser` is called with two arguments: the unique key and callback function. This callback will take an error, if one exists, and the full user object.

In order to get a full user object, we can make a query search for a Mongo `_id`:

```JavaScript
passport.serializeUser((user, done) => {
  done(null, user._id);
});

// turns string `id` into an ObjectID(id).
passport.deserializeUser((id, done) => {
  myDataBase.findOne({ _id: new ObjectID(id) }, (err, doc) => {
    done(null, null);
  });
});
```

---

## Implement the Serialization of a Passport User

Make sure you connect to the database before starting ot listen for requests, as you will get errors otherwise. We can do this by encompassing our `serialization` and `app routes`:

```JavaScript
myDB(async client => {
  const myDataBase = await client.db('database').collection('users');

  // Be sure to change the title
  app.route('/').get((req, res) => {
    // Change the response to render the Pug template
    res.render('index', {
      title: 'Connected to Database',
      message: 'Please login'
    });
  });

  // Serialization and deserialization here...
  passport.serializeUser((user, done) => done(null, user._id));
  passport.deserializeUser((id, done) => {
    myDataBase.findOne({ _id: new ObjectID(id) }, (err, doc) => done(null, doc));
  });

  // Be sure to add this...
}).catch(e => {
  app.route('/').get((req, res) => {
    res.render('index', { title: e, message: 'Unable to connect to database' });
  });
});
// app.listen out here...
```

---

## Authentication Strategies

A strategy is a way of authenticating a user. A strategy can be used to allow users to authenticate based on locally saved information (if you have them register first) or from a variety of providers such as Google or GitHub.

We will use `Passport` middleware. Passport provides a number of set strategies that support authentication using a username and password, GitHub, Google, and more.

```JavaScript
const LocalStrategy = require('passport-local');
```

We tell passport to `use` an instantiated `LocalStrategy` object with a few settings defined. This all goes in the encapsulated database connection, as it relies on it.

```JavaScript
passport.use(new LocalStrategy((username, password, done) => {
  myDataBase.findOne({ username: username }, (err, user) => {
    console.log(`User ${username} attempted to log in.`);
    if (err) return done(err);
    if (!user) return done(null, false);
    if (password !== user.password) return done(null, false);
    return done(null, user);
  });
}));
```

This will try to find a user in your database with the entered username. It will then check for the password to match. Finally if there are no errors, the `user` object is returned and they are authenticated.

Strategies are set up using different settings. It is generally easy to set up based on the README in that strategy's repository.

An example would be the GitHub strategy. You don't need to worry about a username or password, because the user will be sent to GitHub's authenticate page to authenticate. As long as they are logged in and agree then GitHub returns their profile for you to use.

---

## How to Use Passport Strategies

Enable the `showLogin` value for the `'index'` page. This will then render a login page. This form is set up to `POST` to the path `/login`.

To authenticate on this route we need to add a middleware before sending a response. The middleware to use is `passport.authenticate('local')`. This middleware can also take some options such as `{ failureRedirect: '/' }`, which will redirect back to the homepage on failure. If we get through the middleware we will redirect to the `/profile` path, which needs a `GET` which will render the `/profile` html from the `profile.pug` file.

If authentication is successful the user object will be stored in the `req.user`, which we have not used here yet.


```JavaScript
app.get('/', (req, res) => {
  res.render('index', {
    title: 'Connected to Database',
    message: 'Please log in',
    showLogin: true,
  });
});

app.route('/login').post(passport.authenticate('local', { failureRedirect: '/' }), (req, res) => {
  res.redirect('/profile');
});

// fCC doesn't like this format apparently, test wouldn't pass
// app.post('/login', passport.authenticate('local', { failureRedirect: '/' }), (req, res) => {
//   res.redirect('/profile');
// });

app.get('/profile', (req, res) => res.render('profile'));
```

---

## Create New Middleware

At the moment any user can go to the `/profile` route whether they have been authenticated or not just by typing in the URL. We can prevent this by checking if the user is authenticated first before rendering the profile page. This is a perfect example of when to use a middleware.

This is an example of a `ensureAuthenticated` middleware.

```JavaScript
function ensureAuthenticated(req, res, next) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.redirect('/');
};
```

Here we are checking if a user is authenticated by calling `Passport`'s `isAuthenticated` method on the `request` which will check if `req.user` is defined. If it is, then `next()` should be called. Otherwise you can respond to the request with a redirect back to your homepage to login.

We can then pass it on to our `/profile` route as middleware.

```JavaScript
const ensureAuthenticated = (req, res, next) => {
  if (req.isAuthenticated()) return next();
  res.redirect('/');
};

...

app.get('/profile', ensureAuthenticated, (req, res) => res.render('profile'));
```

---

## How to Put a Profile Together

Now that users are authenticated we can use that `req.user` with the stored user object to render the user's information.

We add an `h2` element that says welcome `username`, and add a logout button for the route `/logout`.

```pug
...
  body
    h1.border.center FCC Advanced Node and Express Profile
    h2.center#welcome Welcome, #{username}!
    a(href='/logout') Logout
```

Then in the `/profile` `GET`, we can pass an object like we did for the `/` route, and pass along the `pug` variables with their values:

```JavaScript
app.get('/profile', ensureAuthenticated, (req, res) => {
  return res.render('profile', { username: req.user.username });
});
```

---

## Logging a User Out

`Passport` provides the `req.logout()` method to easily unauthenticate a user. You can then redirect after that.

```JavaScript
app.get('/logout', (req, res) => {
  req.logout();
  res.redirect('/');
});
```

Handling 404 pages is commonly handled through the following middleware. Placed after all other routes.

```JavaScript
app.use((req, res, next) => {
  res.status(404).type('text').send('Not Found');
});
```

---

## Registration of New Users

We first need to enable the `showRegistration` variable for `pug`, to render the HTML for the registration form.

```JavaScript
app.get('/', (req, res) => {
  res.render('index', {
    title: 'Connected to Database',
    message: 'Please log in',
    showLogin: true,
    showRegistration: true,
  });
});
```

This form is setup to `POST` on `/register`.

```JavaScript
app.route('/register').post((req, res, next) => {
  myDataBase.findOne({ username: req.body.username }, (err, foundUser) => {
    if (err) next(err);
    if (foundUser) return res.redirect('/');
    myDataBase.insertOne({
      username: req.body.username,
      password: req.body.password,
    }, (err, doc) => {
      if (err) return res.redirect('/');
      // the inserted document is held within the ops property of the doc
      next(null, doc.ops[0]);
    });
  });
}, passport.authenticate('local', { failureRedirect: '/' }), (req, res) => {
  return res.redirect('/profile');
});
```

First we search the database with the `findOne` method. If there is a found user we redirect back to the index. Otherwise we `insertOne` into the database of the typed in `username` and `password`. This inserted document is then held within the `ops` property of the `doc`. We push these to the `next` to then authenticate the new user like we did previously for the `/login` route. Then finally redirect to the `/profile`.

---

## Hashing Your Passwords

At the moment we are storing `plaintext` passwords. This is **NEVER** okay. it is time to implement `BCrypt` to solve this issue.

We need to handle `hading` in two key areas: where we handle registering/saving a new account, and when you check to see that password is correct on login.

We are currently using `password: req.body.password` to store the user's `plaintext` password. We can hash the password instead by adding the following before our database logic: `const hash = bcrypt.hashSync(req.body.password, 12);` and then replace the `req.body.password`, so that we are now storing `password: hash` in the database.

We can then do the same for our `if (password !== user.password) return done(null, false);`. Instead we use the `bcrypt.compareSync` method.

```JavaScript
const bcrypt = require('bcrypt');

...

  app.route('/register').post((req, res, next) => {
    myDataBase.findOne({ username: req.body.username }, (err, foundUser) => {
      if (err) next(err);
      if (foundUser) return res.redirect('/');
      
      const hash = bcrypt.hashSync(req.body.password, 12);
      
      myDataBase.insertOne({
        username: req.body.username,
        // password: req.body.password,
        password: hash,
      }, (err, doc) => {
        if (err) return res.redirect('/');
        // the inserted document is held within the ops property of the doc
        next(null, doc.ops[0]);
      });
    });
  }, passport.authenticate('local', { failureRedirect: '/' }), (req, res) => {
    return res.redirect('/profile');
  });

...

  passport.use(new LocalStrategy((username, password, done) => {
    myDataBase.findOne({ username: username }, (err, user) => {
      console.log(`User ${username} attempted to log in.`);
      if (err) return done(err);
      if (!user) return done(null, false);
      // if (password !== user.password) return done(null, false);
      if (!bcrypt.compareSync(password, user.password)) return done(null, false);
      return done(null, user);
    });
  }));
```

---

## Clean Up Your Project with Modules
